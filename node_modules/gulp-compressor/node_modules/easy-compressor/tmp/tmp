// -----------------------------------
//             Camera
// -----------------------------------


function Camera (x,y,w,h) {
    BBox.call(this, x,y,w,h)
    this.scale = 1;
    this.reset= function () {
        this.x = this.y = 0;
        this.w=W; this.h=H;
    };
    this.adjust = function () {
        var x = this.x,
            y = this.y;
        var newX = x,
            newY = y;
        var dx = hero.x - x;
        if (dx < 0.25 * W) {
            newX += 0.2 * (hero.x - (x + 0.25 * W));
        } else if (dx > 0.4 * W) {
            newX += 0.2 * (hero.x - (x + 0.4 * W));
        }

        var dy = hero.y - y;
        var falling = gravityDirection * hero.vy > 0;
        if (!falling) {
            var upperYBound = 0.25;
            var lowerYBound = 2 / 3;
            if (dy < upperYBound * H) {
                newY += 0.02 * (dy - upperYBound * H);
            } else if (dy > lowerYBound * H) {
                newY += 0.02 * (dy - lowerYBound * H);
            } else {
                var trend = (gravityDirection > 0) ? 2 / 3 : 1 / 3;
                newY += 0.04 * (dy - trend * H);
            }
        } else /* falling */
        if (dy + hero.h > H / 2) {
            newY += 0.02 * (hero.y + hero.h - (y + H / 2));
        }

        /*        if (newX < 0) newX = 0;
         if (newX + W > worldW) newX = worldW - W;
         if (newY < -camYMargin) newY = -camYMargin;
         if (newY + H > worldH + camYMargin) newY = worldH + camYMargin - H;
         */
        this.x = newX;
        this.y = newY;
    };
};


// -----------------------------------
//             Hero
// -----------------------------------

function Hero(x, y, w, h) {
    BBox.call(this, x, y, w, h);
    this.vx = 0;
    this.vy = 0;
    this.thrust = 0;
    this.jumping = false;
    this.jumpTime = 0;
    this.flipTime = 0;
    this.platform = null;
    this.unfalling = 0;
    this.lastPos = {platform : null, x : 0, y:0 };
    this.color = 0;
    this.life = 100;
    this.losingLife = 0;
    this.reset = function () {
        this.vx = 0;
        this.vy = 0;
        this.jumping = false;
        this.platform = null;
        this.thrust = 0;
        this.life = 100;
        this.losingLife = 0;
        gravityDirection = 1
    };
    this.draw = function () {
        var realColor = (this.color == 0) ? '#F06' : '#99F';
        if (this.losingLife || this.unfalling ) {
            var time = this.losingLife || this.unfalling;
            if (!(Math.floor((Date.now() - time) / 200) % 2)) {
                realColor = '#FFF';
            }
        }
        var xDirection = this.vx >= 0 ? 1 : -1;
        drawSkater(ctx, realColor, this.x, this.y, this.w, this.h, xDirection, gravityDirection);
    }
    this.update = function (dt) {
        //
        if (this.platform && this.platform.color != this.color) {
            this.life -= lifeLooseSpeed*dt;
            if (!this.losingLife) this.losingLife = Date.now();
            if (this.life<0) this.life = 0;
        } else {
            this.losingLife = 0;
        }

        if (this.platform) {
            this.lastPos.platform = this.platform;
            this.lastPos.x = this.x;
            this.lastPos.y = this.y + gravityDirection*blockHeight/2;
        }
        //
        this.vx += this.thrust * dt - this.vx * friction;
        this.vy = clamp(this.vy, -maxVSpeed, maxVSpeed);
        if (this.platform == null) {
            this.vy = this.vy + gravityDirection * gravity * dt;
        } else {
            this.vy = 0;
        }
        var vx = this.vx;
        var vy = this.vy;
        var thisPlatform = this.platform;
        if (thisPlatform && (thisPlatform.vx || thisPlatform.vy)) {
            vx += thisPlatform.vx;
            vy += thisPlatform.vy;
        }
        this.x += vx * dt;
        var oldY = this.y;
        this.y += vy * dt;
        var lowerPointX1 = this.x + this.w * (1 / 2 - 1 / 3);
        var lowerPointX2 = this.x + this.w * (1 / 2 + 1 / 3);

        var lowerPointY = this.y;
        if (gravityDirection == 1) lowerPointY += this.h;
        if (thisPlatform) {
            if (thisPlatform.pointInside(lowerPointX1, lowerPointY) || thisPlatform.pointInside(lowerPointX2, lowerPointY)) {
                return;
            } else {
                this.platform = null;
            }
        }
        // cannot land while jumping.
        if (gravityDirection * this.vy < 0) return;
        // falling ? (and not standing) test if not landed.
        oldY += this.h;
        var platforms = playScreen.platforms;
        for (var i = 0; i < platforms.length; i++) {
            var thisPlatform = platforms[i];
            if (thisPlatform.vSegmentIntersect(lowerPointX1, oldY, lowerPointY) || thisPlatform.vSegmentIntersect(lowerPointX2, oldY, lowerPointY)) {
                this.platform = thisPlatform;
                this.jumping = false;
                if (gravityDirection == 1.0) {
                    this.y = thisPlatform.y - this.h;
                } else {
                    this.y = thisPlatform.y + thisPlatform.h;
                }
                return;
            }
        }
    };
    this.flip = function () {
        hero.vy = -gravityDirection * vPunch;
        this.flipTime = System.applicationTime;
    }
}

// -----------------------------------

function handleInput() {
    if (InputState[65]) setupStandardGradient();
    if (InputState[90]) setupGreenGradient();

    if (InputState[keys.UP]) {
        if (hero.platform != null) {
            hero.platform = null;
            hero.jumping = true;
            hero.jumpTime = System.systemTime;
            hero.vy = -gravityDirection * vPunch;
        }
    } else if (hero.jumping && hero.jumpTime && (System.systemTime - hero.jumpTime < 400)) {
        hero.jumpTime = 0;
        hero.vy /= 3;
    }

    if (InputState[keys.LEFT]) {
        hero.thrust = -maxThrust;
    } else if (InputState[keys.RIGHT]) {
        hero.thrust = maxThrust;
    } else {
        hero.thrust = 0;
    };

    if (InputState[keys.SPACE]) {
        hero.color = 1 - hero.color;
        InputState[keys.SPACE] = false;
    }
}

// -----------------------------------
//             Mountain
// -----------------------------------

function Mountain(baseY, amplitude, basePeriod, yEnd) {
    this.mountainGradient = createGradient([0, 0, 0, amplitude], [
        0, '#FFF',
        0.12, '#EEE',
        0.26, '#DDD',
        0.4, '#BBB',
        1, '#555']);
    this.endGradient = createGradient([0, amplitude, 0, yEnd - baseY], [
        0, '#555',
        1, '#000']);
    this.baseY = baseY;
    this.amplitude = amplitude;
    amplitude /= (1 + 0.8 + 0.16 + 0.18);
    var mainMountain = buildTriangleFunc(basePeriod, amplitude, 280);
    var secMountain = buildTriangleFunc(basePeriod * 0.52341247, amplitude * 0.8, 230);
    var spikes = buildTriangleFunc(basePeriod * 0.133479532, amplitude * 0.14, 10);
    var spikes2 = buildTriangleFunc(basePeriod * 0.174797531, amplitude * 0.12, 10, 15);
    this.mountainFunction = function (x) {
        return (mainMountain(x) + secMountain(x) + spikes(x) + spikes2(x));
    }
    this.draw = function (xOffset, yOffset) {
        xOffset = 0 | (xOffset || 0);
        yOffset = 0 | (yOffset || 0);
        var xMargin = 30;
        var mountainFunction = this.mountainFunction;
        var step = 30;
        var x = -xMargin;
        var xOR = xOffset % step;
        var xBase = xOffset - xOR;
        ctx.save();
        ctx.translate(-xOR - xMargin, this.baseY + yOffset);
        ctx.beginPath();
        ctx.moveTo(0, mountainFunction(xBase + x));
        for (; x < W + 2 * step; x += step) {
            ctx.lineTo(x, mountainFunction(x + xBase));
        }
        ctx.lineTo(x, this.amplitude);
        ctx.lineTo(0, this.amplitude);
        ctx.closePath();
        ctx.lineWidth = 5;
        ctx.strokeStyle = '#000';
        ctx.fillStyle = this.mountainGradient;
        ctx.stroke();
        ctx.fill();
        ctx.fillStyle = this.endGradient;
        ctx.fillRect(0, this.amplitude, W + 2 * step - 1, yEnd - baseY);
        ctx.restore();
    }

    function buildTriangleFunc(period, amp, phase) {
        var halfPeriod = period / 2;
        amp /= halfPeriod;
        phase = phase || 0;
        phase += period;
        return function (x) {
            x += phase;
            x = x % period;
            if (x > halfPeriod) x = period - x;
            return 0 | (x * amp);
        }
    }
}

// -----------------------------------
//             Platform
// -----------------------------------

function MovingPlatform(x1, y1, x2, y2, w, h, speed, period) {
    Platform.call(this, x1, y1, w, h, 0, period);
    x1 *= blockWidth;
    y1 *= blockHeight;
    x2 *= blockWidth;
    y2 *= blockHeight;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.dx = (x2 - x1);
    this.dy = (y2 - y1);
    this.speed = speed;
    this.period = period;
    var length = Math.sqrt(sq(this.dx) + sq(this.dy));
    this.dx /= length;
    this.dy /= length;
    this.vx = this.dx * speed;
    this.vy = this.dy * speed;
    this.direction = 1;
    this.directionSwitchTime = System.applicationTime;
    var superDraw = this.draw;
    this.draw = function () {
        superDraw.call(this);
        var tDiff = this.period - (System.applicationTime - this.colorSwitchTime);
        if (this.colorSwitchTime && (tDiff < 550 && ((0 | (tDiff / 150)) & 1))) {
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x, this.y, this.w, this.h);
        }
    };
    var superUpdate = this.update;
    this.update = function (dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        var scl = (this.x - this.x1) * this.dx + (this.y - this.y1) * this.dy;
        if ((scl < 1) || (scl >= length)) {
            if (scl < 1) this.direction = 1;
            else if (scl >= length) this.direction = -1;
            this.vx = this.direction * this.dx * this.speed;
            this.vy = this.direction * this.dy * speed;
            this.directionSwitchTime = System.applicationTime;
        }
        if (superUpdate) superUpdate.call(this);
    }
}

// -----------------------------------
//             Platform
// -----------------------------------

function Platform(x, y, w, h, color, period) {
    BBox.call(this, x * blockWidth, y * blockHeight, w * blockWidth, h * blockHeight);
    this.color = color;
    this.period = period;
    this.colorSwitchTime = System.applicationTime;
    baseHue = color == 0 ? 259 : 346;
    this.draw = function () {
        ctx.save();
        ctx.translate(this.x, this.y);
        var filler = gradients[this.color];
        ctx.fillStyle = filler;
        //  if (typeof filler == )
        ctx.fillRect(0, 0, this.w, this.h );
        //       ctx.globalCompositeOperation = 'luminosity';
        //        ctx.fillStyle = gradients['o'+this.color]; // '#8FB';
        //      ctx.fillRect(0, 0, 1, 1);
        ctx.restore();
        ctx.strokeStyle = gradients.str;
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x, this.y, this.w, this.h);
    }
    if (period) {
        this.update = function (dt) {
            if (this.period && (System.applicationTime - this.colorSwitchTime > this.period)) {
                this.color = 1 - this.color;
                this.colorSwitchTime = System.applicationTime;
            }
        }
    }
}

function drawPlatform(x, y, w, h, lw, pat) {
    ctx.fillStyle = pat;
    ctx.fillRect(x, y, w, h);
    //ctx.fillRect(10,10,280,40);

    var olw = 5;
    ctx.strokeStyle = '#666';
    ctx.lineWidth = olw;
    ctx.strokeRect(x, y, w, h);

    var ilw = 2;
    ctx.strokeStyle = '#999';
    ctx.lineWidth = ilw;
    //ctx.strokeRect(x,y,w,h);

    var hlw = lw / 2;
    ctx.strokeStyle = '#CCC';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - hlw, y - hlw);
    ctx.lineTo(x - hlw + w + olw, y - hlw);
    ctx.moveTo(x - hlw, y - hlw);
    ctx.lineTo(x - hlw, y - hlw + h);
    ctx.stroke();

    ctx.strokeStyle = '#444';
    ctx.beginPath();
    ctx.moveTo(x - hlw, y - hlw + h);
    ctx.lineTo(x - hlw + w + olw, y - hlw + h);
    ctx.lineTo(x - hlw + w + olw, y - hlw);
    ctx.stroke();

}
// -----------------------------------
//             Stars
// -----------------------------------

function Star(x, y, s) {
    var hs = s / 2;
    var phase = 10 * Math.random();
    this.draw = function () {
        //	console.log(x,y,s);
        ctx.globalAlpha = 0.4 + Math.abs(Math.sin(0.02 * Date.now() * 0.06 + phase));
        ctx.fillStyle = '#FFF';
        ctx.strokeStyle = '#FFF';
        ctx.fillRect(x, y, s, s);
        ctx.lineWidth = hs;
        ctx.beginPath();
        ctx.moveTo(x + hs, y - s);
        ctx.lineTo(x + hs, y + 2 * s);
        ctx.moveTo(x - s, y + hs);
        ctx.lineTo(x + 2 * s, y + hs);
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
}


function drawStars(stars) {
    for (var i = 0; i < stars.length; i++) {
        stars[i].draw();
    }
}

function buildStars(starCount, w, h, minSize, maxSize) {

    var stars = [];

    for (var i = 0; i < starCount; i++) {
        var newStar = new Star(w*Math.random(), h*Math.random(), minSize + (maxSize - minSize) * Math.random());
        stars.push(newStar);
    }
    return stars;
}
// -----------------------------------
//             Trigger
// -----------------------------------

//    ['msg', 1, 9, 16, 'use arrow keys ← ↑ → to move']

function Trigger(args) {
    BBox.call(this, args[1] * blockWidth, args[2] * blockHeight, args[3] * blockWidth, args[4] * blockHeight);
    var type = args[0];
    if (type == 'msg') {
        // msg : x, y, size , txt , [ duration]
        //        this.draw = function() {
        //        };
    } else if (type == 'end') {
        this.draw = function () {
            ctx.save();
            ctx.globalAlpha *= (0.3 + 0.07 * Math.sin(0.006 * Date.now()));
            ctx.fillStyle = '#9F9';
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.restore();
        };
        this.update = function () {
            var oh = this.overlaps(hero);
            if (oh) {
                playScreen.currentLevel++;
                if (playScreen.currentLevel == levels.length) {
                    // player did beat the game...
                    System.launchScreen(winScreen);
                } else {
                    System.launchScreen(playScreen);
                }
            }
        };
    } else if (type == 'flip') {
        var flipTime = -1000;
        var angle = args[5] == 1 ? -Math.PI / 2 : Math.PI / 2;
        this.draw = function () {
            /*            ctx.save();
             ctx.globalAlpha *= (0.3 + 0.07 * Math.sin(0.006 * Date.now()));
             ctx.fillStyle = '#9F9';
             ctx.fillRect(this.x, this.y, this.w, this.h);
             ctx.restore();
             */
            var dy = 0.1 * this.w * Math.sin(0.006 * Date.now())
            drawArrow(this.x, this.y + dy, this.w, this.h, angle, null, '#F66', 3);
        };
        this.update = function () {
            if (System.systemTime - flipTime < 1200) return;

            var oh = this.overlaps(hero);
            if (oh) {
                hero.flip();
                flipTime = System.systemTime;
                gravityDirection *= -1;
            }
        }
    }
}